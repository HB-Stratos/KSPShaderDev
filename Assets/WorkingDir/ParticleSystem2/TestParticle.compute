#pragma enable_d3d11_debug_symbols

#pragma kernel _Init
#pragma kernel _CpuEmit
#pragma kernel _EarlyUpdate
#pragma kernel _Update

//TODO lots of fixing to do
// Available Indices must be maintained to allow for random particle lifetimes
// Somehow data buffer coherence should be maintaned, maybe the stack-like behavior of the avaliable index buffer works here?
// I think the index buffer wouldn't work, double-buffering the particle buffer and making it (fake) append would work.
// need to be careful with maintaining ability to have parented particles -> ffs this might break memory coherence through appending


// do not make this overly high, it determines shader size
// //TODO this should really be dynamic, not user defined in source
// int maxParticles = 10000;

//Only some specific values can be gathered this way, check documentation (that doesn't exist rn)
int _DeltaTime < string CpuSource = "Time.deltaTime" ; > ; //Really we should not use Time.DeltaTime if this is e.g. updated in fixed update
int rendertype < string RenderType = "Triangles"; > ;

struct Particle
{
    float3 position; //must be first entry by convention
    float life;
    float3 velocity;
    int index; //index of particle in the data buffer, used for parenting
    int parent;
};

RWStructuredBuffer<int> _CurrAvailableIndices;

RWStructuredBuffer<int> _CurrAliveIndices;

RWStructuredBuffer<Particle> _CurrData;
uint _CurrDataSize;
uint _CurrDataStride;
uint _CurrDataInUseCount = 0;

RWStructuredBuffer<int> _UpdateIndArgs;

struct PersistentGlobalData
{
    float timeSinceLastSpawn;
};

struct Render
{
    float3 pos0;
    float3 pos1;
    float3 pos2;
};
//Note the trailing semicolon. Important!

//TODO figure out a way to request data from the CPU dynamically

// How a new particle should look. Return a Particle.
Particle Emit()
{
    Particle p;
    p.life = 10;
    p.position = float3(0, 0, 0);
    p.velocity = float3(0, 0, 1);
    p.index = -1;
    p.parent = -1;
    return p;
}


void AddRender(Render tri)
{

}

Particle GetParent()
{

}

// Update is only allowed to modify data within Particle p.
void Update(inout Particle p)
{
    p.position += p.velocity * _DeltaTime;

    Render tri;
    tri.pos0 = float3(0, 0, 0);
    tri.pos1 = float3(0, 1, 0);
    tri.pos2 = float3(0, 0, 1);
    AddRender(tri);
}


// int IncrementDataCounter()
// {
//     _CurrDataInUseCount++;
//     return _CurrData.IncrementCounter();
// }
// int DecrementDataCounter()
// {
//     _CurrDataInUseCount--;
//     return _CurrData.DecrementCounter();
// }



uint ReviveParticleIndex()
{
    uint availableIndicesIndex = _CurrAvailableIndices.DecrementCounter();
    uint newParticleIndex = _CurrAvailableIndices[availableIndicesIndex];
    uint aliveIndicesIndex = _CurrAliveIndices.IncrementCounter();
    _CurrAliveIndices[aliveIndicesIndex] = newParticleIndex;
    return newParticleIndex;
}
//TODO do not use this, instead a particle must emit itself every frame, otherwise I need a search through aliveIndices
// void KillParticleIndex(uint index)
// {
//     uint aliveIndicesIndex
// }

void _Emit(Particle p)
{
    uint newParticleIndex = ReviveParticleIndex();
    // if (newParticleIndex >= _CurrDataSize) return; //TODO reinstate this with working implementation to prevent out of bounds write
    
    //new particle index can also be used for parenting, would require multiple emits in the same call though
    p.index = newParticleIndex;
    _CurrData[newParticleIndex] = p;
}

//TODO kinda ugly to have only one thread in group, fix maybe?
//TODO make particle parenting possible
[numthreads(1, 1, 1)]
void _CpuEmit()
{
    _Emit(Emit());
}

//TODO this would ideally be (64, 1, 1), but this is not possible with the current copy count.
//TODO WARNING if this was 64 threads I might run too many threads and consume more data than present in the buffer
//TODO ffs this implementation of reading and writing may cause a race condition when accessing parents
[numthreads(1, 1, 1)]
void _Update(uint3 id : SV_DispatchThreadID)
{
    //TODO call Update() with particle from struct, maybe handle emitting itself again?
    uint processedParticleIndex = _CurrAliveIndices[id.x];
    Particle p = _CurrData[processedParticleIndex];
    Update(p);
    _CurrData[processedParticleIndex] = p;
}

[numthreads(1, 1, 1)]
void _EarlyUpdate()
{
    // _CurrDataInUseCount = _CurrData.IncrementCounter();
    // _CurrData.DecrementCounter();
    uint threadGroupSize = 64;
    _UpdateIndArgs[0] = (_UpdateIndArgs[0] + (threadGroupSize - 1)) / threadGroupSize;
}

[numthreads(64, 1, 1)] //Initialize the available indices buffer
void _Init(uint3 id : SV_DispatchThreadID)
{
    
    if (id.x == 0)
    {
        _CurrData.GetDimensions(_CurrDataSize, _CurrDataStride);
    }
    if (id.x < _CurrDataSize) //TODO This is probably a race condition

    {
        _CurrAvailableIndices[id.x] = id.x;
    }
}



