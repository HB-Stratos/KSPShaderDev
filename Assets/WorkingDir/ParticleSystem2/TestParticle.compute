#pragma kernel _Init
#pragma kernel _CpuEmit
#pragma kernel _EarlyUpdate
#pragma kernel _Update

//TODO lots of fixing to do
// Available Indices must be maintained to allow for random particle lifetimes
// Somehow data buffer coherence should be maintaned, maybe the stack-like behavior of the avaliable index buffer works here?
// I think the index buffer wouldn't work, double-buffering the particle buffer and making it (fake) append would work.
// need to be careful with maintaining ability to have parented particles -> ffs this might break memory coherence through appending


// do not make this overly high, it determines shader size
// //TODO this should really be dynamic, not user defined in source
// int maxParticles = 10000;

//Only some specific values can be gathered this way, check documentation (that doesn't exist rn)
int _DeltaTime < string CpuSource = "Time.deltaTime" ; > ; //Really we should not use Time.DeltaTime if this is e.g. updated in fixed update
int rendertype < string RenderType = "Triangles"; > ;

struct Particle
{
    float3 position; //must be first entry by convention
    float life;
    float3 velocity;
};

// RWStructuredBuffer<float3> vertices;
// RWStructuredBuffer<int> triangles;

ConsumeStructuredBuffer<int> _CurrAvailableIndices;
AppendStructuredBuffer<int> _NextAvailableIndices;

// ConsumeStructuredBuffer<int> _CurrAliveIndices;
// AppendStructuredBuffer<int> _NextAliveIndices;

RWStructuredBuffer<Particle> _CurrData;
uint _CurrDataCount;
uint _CurrDataStride;
uint _CurrDataInUseCount = 0;
// RWStructuredBuffer<Particle> _NextData;

RWStructuredBuffer<int> _UpdateIndArgs;

struct PersistentGlobalData
{
    float timeSinceLastSpawn;
};

struct Render
{
    float3 pos0;
    float3 pos1;
    float3 pos2;
};
//Note the trailing semicolon. Important!

//TODO figure out a way to request data from the CPU dynamically

// How a new particle should look. Return a Particle.
Particle Emit()
{
    Particle p;
    p.life = 10;
    p.position = float3(0, 0, 0);
    p.velocity = float3(0, 0, 1);
    return p;
}

void AddRender(Render tri)
{

}

Particle GetParent()
{

}

// Update is only allowed to modify data within Particle p.
void Update(inout Particle p)
{
    p.position += p.velocity * _DeltaTime;

    Render tri;
    tri.pos0 = float3(0, 0, 0);
    tri.pos1 = float3(0, 1, 0);
    tri.pos2 = float3(0, 0, 1);
    AddRender(tri);
}


int IncrementDataCounter()
{
    _CurrDataInUseCount++;
    return _CurrData.IncrementCounter();
}
int DecrementDataCounter()
{
    _CurrDataInUseCount--;
    return _CurrData.DecrementCounter();
}



void _Emit(Particle p)
{
    uint newParticleIndex = IncrementDataCounter();
    if (newParticleIndex >= _CurrDataCount) return;
    
    //new particle index can also be used for parenting, would require multiple emits in the same call though
    _CurrData[newParticleIndex] = p;
}

//TODO kinda ugly to have only one thread in group, fix maybe?
//TODO make particle parenting possible
[numthreads(1, 1, 1)]
void _CpuEmit()
{
    _Emit(Emit());
}

//TODO this would ideally be (64, 1, 1), but this is not possible with the current copy count.
//TODO ffs this implementation of reading and writing may cause a race condition when accessing parents
[numthreads(1, 1, 1)]
void _Update(uint3 id : SV_DispatchThreadID)
{
    //TODO call Update() with particle from struct, maybe handle emitting itself again?
    Particle p = _CurrData[id.x];
    Update(p);
    _CurrData[id.x] = p;
}

[numthreads(1, 1, 1)]
void _EarlyUpdate()
{
    _CurrDataInUseCount = _CurrData.IncrementCounter();
    // _CurrData.DecrementCounter();
    _UpdateIndArgs[0] = _CurrDataInUseCount;
}

//TODO only dispatch one init thread, or init the entire particle buffer
[numthreads(64, 1, 1)] //Initialize the available indices buffer
void _Init(uint3 id : SV_DispatchThreadID)
{
    // _NextAvailableIndices.Append(id.x);
    if (id.x == 0)
    {
        _CurrData.GetDimensions(_CurrDataCount, _CurrDataStride);
    }
}



